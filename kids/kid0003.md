---
tags: KERI
email: sam@samuelsmith.org
---

# KID0003  Event and Extracted Data Set Serialization 

[![hackmd-github-sync-badge](https://hackmd.io/yd8X2Z5JRW2g9FI73h93xQ/badge)](https://hackmd.io/yd8X2Z5JRW2g9FI73h93xQ)


(See WhitePaper Version 2.43)

There are two serialization algorithms needed for KERI. The first is the serialization of full events.  The second is the serialization of data sets extracted from a full event. 

In KERI, complete key events need to be serialized in order to create cryptographic signatures of each event. Complete events also need to be serialized in order to create cryptographic digests of each event. Complete events are propagated over the network in signed serialized form. Complete events also need to be de-serialized after network propagation such that the resultant de-serialization preserves the semantic structure of the data elements in the event. Because the cryptographic material in the events may be of variable length, a fixed field length serialization is not a viable approach. Consequently KERI must support variable length field serialization. Moreover serialization encodings that support arbitrary nested self-describing data structures provide future proofing to event composition. Notably, JSON, CBOR, and MsgPack are well known broadly supported serialization encodings that support arbitrary nested self-describing data structures. JSON is an ASCII text encoding that is human readable, albeit somewhat verbose, that is commonly used in web applications. On the other hand both CBOR and MsgPack are binary encodings that are much more compact. Supporting all three encodings (and possibly others) would satisfy a wide range of application, transport, and resource constaints. Importantly, because only the controller of the associated identifier prefix may compose KERI events, the ordering of elements in the event serialization may be determined solely by that controller. Other entities may sign the event serialization provided by the controller but do not need to provide a serialization of their own.

Within the KERI protocol cryptographic digests and signatures are created of specified subsets of the data elements extracted from complete KERI key events. Consequently these extracted data sets also need to be serialized. Importantly, however, the extracted data set serialization do not need to be propagated over the network. This means that the serializations do not need to preserve the semantic structure of the data. This allows extracted data serialization encoding to simplified. These digests of extracted data, however, need to be reproducible by any other entity. This means that the ordering of the data elements in the serialization must be exactly specified. 

In summary, the necessary constraint for complete event serialization is support for arbitrary data structures with variable length fields that are serializable and de-serializable in multiple formats. Reproducible ordering is not a necessary constraint. The necessary constraint for extracted data element sets is reproducible ordering but there is no need to de-serialize.

Beneficial if not necessary constraints are ease and convenience of development and maintenance of the associated code libraries. One possibility that was considered and rejected would be to use same serializations for both the complete event serialization and the extracted data set serialization. The problem with that approach is that on an event by event basis the serialization encoding may change, that is, one event may be encoded using JSON and another using CBOR. This would require keeping track of which encoding was used on the event in order to reproducibly perform an extracted data serialization. More problematic is that for delegated events, the extracted data set digest included in one event may be from data extracted from an event belonging to a different identifier. In such a situation, keeping track of the encoding provides an inconvenience that obviates the advantages of using the same encodings for both events and extracted data sets. Given this, then a simplified but repeatable encoding algorithm may be used for the extracted data set serializations. Simplified because the extracted data sets do not need to be de-serialized.

The one constraint for extracted data set serializations is that the ordering of elements be exactly specified. One way to simplify that specification is to use the ordering of data elements in the complete event serialization. But this means imposing an ordering constraint on the complete event serialization. The advantage is that ordering is only expressed once per event not once per extracted data set. This better future proofs the protocol as there is always only one place for ordering and that is the complete event element ordering.

Another benefit of ordering the complete event serialization is that automated self-contained discovery of the serialization encoding used in an event becomes trivialized by requiring that the first element in the serialization be the version string element. A de-serializer may then unambiguously determine the encoding by inspecting the first few bytes of any serialized event. This better supports a wider variety of transport protocols and databases.

Until recently native JSON serialization libraries in JavaScript did not preserve a logical ordering of elements from a Mapping (JavaScript Object) data structure. The only ordering possible was lexicographic by sorting the fields in the mapping by their labels. This meant that arbitrary logical ordering of mapping fields was not possible and no semantic meaning could be imposed on the serialization based on order of appearance of fields. One could approximate some ordering by imposing lexicographic constraints on the field names but that makes the field names less usable. Ordered mappings support a logical ordering by preserving the order of creation of fields in the mapping. Any arbitrary order may be imposed by changing the order of creation of the fields in the mapping.

Fortunately Javascript ES6 (ES2015) and later now provide a mechanism to impose property (field) creation order on JSON.stringify() serializations. The latest versions of Javascript now natively preserve property creation order when serializing. This means that de-serialization will automatically recreate the properties in the same order as serialized. For those implementations of Javascript ES6 or later that do not yet support native JSON.stringify property creation ordering, a JSON.stringify parameter replacer function that uses the [[ownPropertyKeys]] internal method, namely, Reflect.ownKeys(object) may be employed to ensure property creation order. This means that native Javascript support may be easily and broadly provided. All major JavaScript implementations now support JavaScript ES6. Example JavaScript code is provided later in this document.

Other languages like Python, Ruby, Rust etc. have long supported native creation order preserving serializations of ordered mappings. These preserve field element (property equivalent) creation order. This in combination with the recent JavaScript support means that KERI may impose an ordering constraint on complete event data elements that may be used for canonical ordering of both complete events and extracted data element sets.

## Event Serialization Algorthm

The ordering of elements in each mapping in each event element is specified (see below). This includes nested elements. Serialization using the standard JSON, CBOR, and MsgPack libraries follow a recursive depth first traversal of nested elements.

Complete events are serialized/de-serialized from/to ordered mappings using the JSON, CBOR or MsgPack functions for serializing/deserializing.  Each programming language may name the functions differently for serialization/de-serialization. In JavaScript they are JSON.stringify/JSON.parse. In Python they are json.dumps/json.loads. Likewise the CBOR and MsgPack libraries in each language may use different names for these functions.

The JSON serialization is without white space.

## Extracted Data Set Serializaton

The extracted data set serialization algorithm serializes the elements in each set using the same order of appearance as the associated event. Nested elements are serialized using a depth first traversal.

The serialization appends (concatenates) the serialized value of each element as it encounters it. Each element value is serialized as a UTF-8 encoded string of characters. 

Each implementation must perform the recursive depth first traversal.

In order to ensure that the extracted serializations are unique, the values or value sets must be unique. Uniqueness may be obtained by some combination of unique values and unique ordering of values. In most cases the ordering is explicit which may by itself ensure that the serialization is unique. Any change in a value at a location changes serialization of the set of values. However, the data element list  and the perm list in a delegation do not have a predefined ordering of their enclosed mappings. This means that that associated values must either be unique or must appear in a mapping with a unique combination of values. Seal values include crptographic digests which are unique.

## Event Ordered Element Sets

As of this writing KERI has 5 different types of key events, these are:

Inception Event  
Rotation Event  
Interaction Event  
Delegated Inception Event  
Delegated Rotation Event  

Each event may have slightly different sets of elements. The events are expressed as an ordered mapping of (label, value) pairs. The values may include lists (arrays) of values or (label, value) pairs or nested ordered mappings of (label, value) pairs.

An Interaction event in a delegated key event stream has the identical element set of an interaction event in a non-delegated key event stream. As a result the ordering from the non-delegated interaction event may be applied to the delegated interaction event. 

In the following specifications the element sets are expressed in JSON format. Both MsgPack and CBOR natively support JSON compatible field element values for the various data types as well as ascii field element labels. As a result a JSON constrained representation is sufficient to ensure interoperabilty.

### Element Labels

vs   = version string (all)  
pre  = autonomic identifier prefix (all)  
sn   = sequence number (all)  
ilk  = event ilk type (all)  
dig  = digest previous event (rot, ixn, drt)  
sith = signing threshold or list of weighted thresholds (icp, rot, dip, drt)  
keys = list of signing public keys (icp, rot, dip, drt)  
nxt  = next digest of ensuing threshold and signers (icp, rot, dip, drt)  
toad = witness threshold of accountable duplicity  tally (icp, rot, dip, drt)  
wits = witness list of aid prefixes (icp, dip)  
cuts = witness cut prune list (rot, drt)  
adds = witness add graft list (rot, drt)  
cnfg = config data list (icp)   
data = data seal list (rot, ixn)  
perm = list of ordered mappings of delegation permissions (dip, drt)  
seal = delegation seal (dip, drt)  


### Version String

Version string enables discovery of encoding when parsing serialized
packet.


Parts:
    KERI version kind size terminal
    
    KERI = KERI event packet identifier
    version = major minor = hex characters = 10 for 1.0
    kind  = encoding one of CBOR, JSOM, MGPK
    size = 6 character hex string length of serialized event 
           max size 16777215 bytes in version 1.0
    terminal is "_" underscore for future proofing


version tuple = (1, 0) = (major, minor)

major increments with backward breaking changes
minor increments with backward compatible changes

Serialize event with 0000 size value in version string.

Terminal characters enables detectable parsable change in length of version string in the future

Embedded version string with size obviates the needed for 
separate header when using headerless transports (not http).
Because version string is embedded in event it is included in signed portion so is protected by authentication of signature.
An attacker may not change the size of the event without breaking the signature.

Serialize event with zero'd size in version string

```
KERI10CBOR000000_
KERI10JSON000000_
KERI10MGPK000000_
```

Then replace the 000000 size field inside the version string  of the serialized event with lowercase hex of actual size of serialized event.

```
KERI10CBOR000115_
KERI10JSON00011c_
KERI10MGPK000115_
```

Then sign the encoded event that now has the correct size in its version string.

### Mutually Exclusive Multi-Type Support

Two event elements values may be of more than one type. The design decision was primarily practical. Although the idea of multiple types of values for a given element label introduces complexity it was less complexity then adding an additional element with unique label for each type.  

This trade-off happens with the value types are mutually exclusive. This means that should there be two different labels one for each type, then the presence of both labels must be handled. This is either an error or there must be a prioritization of
the labels. If both are present the implementation must decide which one is to be used. Clearly both should never be present so its an error. There is no way to infer the intent of the provider. But how best to enforce the error?  

The code to enforce mutual exclusivity is at least as complex as the code to do a type check switch.  In either case, because both types must separably supported, the code to support both types after the switch or prioritization is the same. But having only one field label with more than one type value means there is no chance of prioritization errors due to ambiguity of intent. One field forces zero ambiguity of intent. In languages like Python that are duck typed, the consensus is that a type switch is preferred to multiple fields.  

In general, an event's serialization should not be the operative representation. This distinction is not a problem for most languages, but does arise frequently in JavaScript where JSON is so closely tied to the operative representation. In non JavaScript implementations extraction from a serialization should handle the type switch and if desirable the representation after extraction may have multiple attribute labels, one for each value type.

In conclusion, the design decision here is that an or-ing of value types in a serialization field element where those value types are mutually exclusive is practically less error prone and less complex than adding mutually exclusive field labels, one for each value type to the serialization.  





### Inception Event


```javascript
{
  "vs"   : "KERI10JSON00011c_",
  "pre"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qualified Base64
  "sn"   : "0",  // lowercase hex string no leading zeros
  "ilk"  : "icp",
  "sith" : "1",  // lowercase hex string no leading zeros or list
  "keys" : ["AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM"],  // list of qual Base64
  "nxt"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
  "toad" : "1",  // lowercase hex string no leading zeros
  "wits" : [],  // list of qualified Base64
  "cnfg" : []  // list of config ordered mappings
}

```

### Rotation Event


```javascript
{
  "vs"   : "KERI10JSON00011c_",
  "pre"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qualified Base64
  "sn"   : "1",  // lowercase hex string no leading zeros
  "ilk"  : "rot",
  "dig"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
  "sith" : "1",  // lowercase hex string no leading zeros or list
  "keys" : ["AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM"],  // list of qual Base64
  "nxt"  : 'DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM',  // qualified Base64
  "toad" : "1",  // lowercase hex string no leading zeros
  "cuts" : [],  // list of qualified Base64
  "adds" : [],  // list of qualified Base64
  "data" : []  // list of seal ordered mappings
}

```

### Interaction Event

```javascript
{
  "vs"   : "KERI10JSON00011c_",
  "pre"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qualified Base64
  "sn"   : "1",  // lowercase hex string no leading zeros
  "ilk"  : "ixn",
  "dig"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
  "data" : []  // list of seal ordered mappings
}

```

### Delegating Interaction Event

```javascript
{
  "vs"   : "KERI10JSON00011c_",
  "pre"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qualified Base64
  "sn"   : "1",  // lowercase hex string no leading zeros
  "ilk"  : "ixn",
  "dig"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
  "data" : [
             {
               "id"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qual Base64
               "sn"  : "0",  // hex string no leading zeros 
               "dig" : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qual Base64
             }
           ]  // list of seal ordered mappings
}

```

### Delegating Rotation Event


```javascript
{
  "vs"   : "KERI10JSON00011c_",
  "pre"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qualified Base64
  "sn"   : "1",  // lowercase hex string no leading zeros
  "ilk"  : "rot",
  "dig"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
  "sith" : "1",  // lowercase hex string no leading zeros or list
  "keys" : ["AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM"],  // list of qual Base64
  "nxt"  : 'DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM',  // qualified Base64
  "toad" : "1",  // lowercase hex string no leading zeros
  "cuts" : [],  // list of qualified Base64
  "adds" : [],  // list of qualified Base64
  "data" : [
             {
               "id"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qual Base64
               "sn"  : "0",  // hex string no leading zeros 
               "dig" : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qual Base64
             }
           ]  // list of seal ordered mappings
}

```

### Delegated Inception Event

```javascript
{
  "vs"   : "KERI10JSON00011c_",
  "pre"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qualified Base64
  "sn"   : "0",  // lowercase hex string no leading zeros
  "ilk"  : "dip",
  "sith" : "1",  // lowercase hex string no leading zeros or list
  "keys" : ["AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM"],  // list of qual Base64
  "nxt"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
  "toad" : "1",  // lowercase hex string no leading zeros
  "wits" : [],  // list of qualified Base64
  "perm" : [],   // list of ordered mappings of delegation permissions
  "seal" : 
           {
             "id"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qual Base64
             "sn"  : "4",  // hex string no leading zeros
             "ilk" : "ixn", 
             "dig" : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qual Base64
           }
}

```

### Delegated Rotation Event


```javascript
{
  "vs"   : "KERI10JSON00011c_",
  "pre"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qualified Base64
  "sn"   : "1",  // lowercase hex string no leading zeros
  "ilk"  : "drt",
  "dig"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
  "sith" : "1",  // lowercase hex string no leading zeros
  "keys" : ["AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM"],  // list of qual Base64
  "nxt"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
  "toad" : "1",  // lowercase hex string no leading zeros
  "cuts" : [],  // list of qualified Base64
  "adds" : [],  // list of qualified Base64
  "perm" : [],   // list of ordered mappings of delegation permissions
  "seal" : 
           {
             "id"  : "AmwyZ-i0d8JZaU6JR2nAoTNZH3ULvYAfSVPzhzS6b5CM",  // qual Base64
             "sn"  : "4",  // hex string no leading zeros
             "ilk" : "ixn", 
             "dig" : 'DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM',  // qual Base64
           }
}

```


### Delegated Interaction Event

```javascript
{
  "vs"   : "KERI10JSON00011c_",
  "pre"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qualified Base64
  "sn"   : "1",  // lowercase hex string no leading zeros
  "ilk"  : "ixn",
  "dig"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
  "data" : []  // list of seal ordered mappings
}

```



### Event Receipt Message (Witnesse(s) or Watcher(s) or Validator(s))

```javascript
{
  "vs"   : "KERI10JSON00011c_",
  "pre"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qualified Base64
  "sn"   : "1",  // lowercase hex string no leading zeros
  "ilk"  : "rct",
  "dig"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64 Optional
  "wits" : // list qualified Base64 prefixes of witnesses, watchers, validators
           [ 
             "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM", 
             "AmwyZ-i0d8JZaU6JR2nAoTNZH3ULvYAfSVPzhzS6b5CM"
           ],   
  "sigs" : // list qualified Base64 signatures, one per witness in order
           [
             "0BSb9qBNXUerVs4IDYnai29AXcPQJtudLPfzfvehicA7LrswWBPmNlNQK9gIJB4pny2YpuB3m6-pgyl4cU65RRCA",
             "0BIJB4pny2YpuB3m6-pgyl4cU65RRCASb9qBNXUerVs4IDYnai29AXcPQJtudLPfzfvehicA7LrswWBPmNlNQK9g"
           ]
}

```




## Ordered Extracted Data Element Set Labels

The lists provide the order that the values from the respective data elements are to be concatenated in the extracted serialized data. When the data element value is itself a collection of data elements such as a list or mapping then the elements of the
collection that is the value are to be concatenated in the order of appearance in the collection.
This rule must be recursively applied.  For example the next signing config digest has two primary elements:

```javascript
[
  "sith",
  "keys"
]

```
But the "keys" element is itself a list. So the concatenated data will be the "sith" value with each key from the "keys" element concatenated in order of appearance in the "keys" list. The "sith" element may also be a list or list of lists when using a fractionally weighted threshold.


### Next Signing Config Digest for Future Event Labels

```javascript
[
  "sith",  
  "keys",  
]

```


### Prefix Derivation Data from Inception Event Labels

```javascript
[
  "vs",
  "sn",
  "ilk",
  "sith",
  "keys",
  "nxt",
  "toad",
  "wits",
  "cnfg"
]

```


### Delegated Prefix Derivation Data from Delegated Inception Event Labels

```javascript
[
  "vs",    // delegated event
  "sn",    // delegated event
  "ilk",   // delegated event
  "sith",  // delegated event
  "keys",  // delegated event
  "nxt",   // delegated event
  "toad",  // delegated event
  "wits",  // delegated event
  "perm",  // delegated event
  "seal"   // delegated event
]

```

### Delegating Seal Digest Data

digest of complete serialized delegated event





### Digest Seal Labels

Fields

```javascript
[ 
  "dig"
]
```

### Digest Seal

```javascript
{
  "dig"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
}
```

### Hash Tree Root Seal Labels

Fields

```javascript
[ 
  "root"
]
```

### Has Tree Root Seal

```javascript
{
  "root"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
}
```

### Event Seal Labels

```javascript
[
  "pre",
  "sn",   
  "dig" 
]
```

### Event Seal

```javascript
{
  "pre"   : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qualified Base64
  "sn"   : "1",  // hex string no leading zeros
  "dig"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
}
```

### Event Location Seal Labels

Fields

```javascript
[
  "pre",  // delegating event
  "sn",   // delegating event
  "ilk",  // delegating event
  "dig"   // delegating event of previous event
]
```

### Event Location Seal

```javascript
{
  "pre"  : "AaU6JR2nmwyZ-i0d8JZAoTNZH3ULvYAfSVPzhzS6b5CM",  // qualified Base64
  "sn"   : "1",  // hex string no leading zeros
  "ilk"  : "ixn",
  "dig"  : "DZ-i0d8JZAoTNZH3ULvaU6JR2nmwyYAfSVPzhzS6b5CM",  // qualified Base64
}
```



## JavaScript Ordered Object Property Serialization

The following code snippet shows how to enforce object property creation order preserving serialization using JSON.stringify for ES6 and later.

### Code Snippet

```javascript
"use strict"

// Spec http://www.ecma-international.org/ecma-262/6.0/#sec-json.stringify
const replacer = (key, value) =>
  value instanceof Object && !(value instanceof Array) ? 
    Reflect.ownKeys(value)
    .reduce((ordered, key) => {
      ordered[key] = value[key];
      return ordered 
    }, {}) :
    value;

// Usage

// JSON.stringify({c: 1, a: { d: 0, c: 1, e: {a: 0, 1: 4}}}, replacer);


var main = function() 
{
    console.log("Running Main.");
    
    let x = { zip: 3, apple: 1, bulk: 2, _dog: 4 };
    let y = JSON.stringify(x);
    console.log(y);
    console.log(Object.keys(x));
    console.log(Object.getOwnPropertyNames(x));
    console.log(Reflect.ownKeys(x));
    console.log(replacer);
    let w  = {w: 1, a: x, c: {e: 2, b: 3}};
    let z = JSON.stringify(x, replacer);
    console.log(z);
    let v = JSON.stringify(w, replacer);
    console.log(v);
    
}

if (require.main === module) 
{
    main();
}


//nodejs % node play.js
//Running Main.
//{"zip":3,"apple":1,"bulk":2,"_dog":4}
//[ 'zip', 'apple', 'bulk', '_dog' ]
//[ 'zip', 'apple', 'bulk', '_dog' ]
//[ 'zip', 'apple', 'bulk', '_dog' ]
//[Function: replacer]
//{"zip":3,"apple":1,"bulk":2,"_dog":4}
//{"w":1,"a":{"zip":3,"apple":1,"bulk":2,"_dog":4},"c":{"e":2,"b":3}}

```

### Background

We may impose ordered serialization with the JSON.stringify method  by using the replacer  option and the [[ownPropertyKeys]] internal method added in Javascript ES6 exposed as Reflect.ownKeys().  This method is provided in JavaScript ES6 (2015). [[ownPropertyKeys]] uses the property creation order.  At the time of ES6, JSON.stringify was not required to use the [[ownPropertyKeys]] iteration order (ie property creation order). This appears to have been fixed in later versions of ES. (See the discussion below). As of this writing nodejs v14.2.0 and the latest versions of Chrome, Safari, and Firefox all appear to preserve property creation order  in JSON.stringify(). This means that we can depend on and use that ordering in the specification.  For earlier versions but still with support ES6, a custom replacer function for JSON.stringify(x, replacer) will ensure that property creation order is used.  Earlier versions that do not support ES6 may still work with an ES6 polyfill if that includes support for [[ownPropertyKeys]].

https://stackoverflow.com/questions/30076219/does-es6-introduce-a-well-defined-order-of-enumeration-for-object-properties/30919039

In ES6 the stringify order is not required to follow the ownPropertyKeys (property creation order) ordering but this will be fixed in ES 2020. ES11.  It appears that the  Babel polyfill as of 2020 already supports ES2020 already.

https://www.keithcirkel.co.uk/metaprogramming-in-es6-part-2-reflect/

Reflect.ownKeys ( target )

This has already been discussed a tiny bit in this article, you see Reflect.ownKeys implements [[OwnPropertyKeys]] which if you recall above is a combination of Object.getOwnPropertyNames and Object.getOwnPropertySymbols. This makes Reflect.ownKeys uniquely useful. Lets see shall we:

```javascript


var myObject = {
  foo: 1,
  bar: 2,
  [Symbol.for('baz')]: 3,
  [Symbol.for('bing')]: 4,
};

assert.deepEqual(Object.getOwnPropertyNames(myObject), ['foo', 'bar']);
assert.deepEqual(Object.getOwnPropertySymbols(myObject), [Symbol.for('baz'), Symbol.for('bing')]);

// Without Reflect.ownKeys:
var keys = Object.getOwnPropertyNames(myObject).concat(Object.getOwnPropertySymbols(myObject));
assert.deepEqual(keys, ['foo', 'bar', Symbol.for('baz'), Symbol.for('bing')]);

// With Reflect.ownKeys:
assert.deepEqual(Reflect.ownKeys(myObject), ['foo', 'bar', Symbol.for('baz'), Symbol.for('bing')]);


```



https://github.com/tc39/proposal-for-in-order

https://tc39.es/ecma262/#sec-ordinaryownpropertykeys

https://2ality.com/2015/10/property-traversal-order-es6.html#traversing-the-own-keys-of-an-object

https://www.stefanjudis.com/today-i-learned/property-order-is-predictable-in-javascript-objects-since-es2015/


https://medium.com/@robertgrosse/how-es6-classes-really-work-and-how-to-build-your-own-fd6085eb326a


